{"name":"t_bird","tagline":"Straight forward file uploads for Ruby Apps","body":"_Uploading is... fun, fun, fun, 'til daddy takes the `t_bird` away._\r\n\r\n## Project Status\r\n\r\n- Version: [![Gem Version](https://badge.fury.io/rb/t_bird.png)](http://badge.fury.io/rb/t_bird)\r\n- Build: [![Build Status](https://secure.travis-ci.org/xentek/t_bird.png)](http://travis-ci.org/xentek/t_bird)\r\n- Dependencies: [![Dependency Status](https://gemnasium.com/xentek/t_bird.png)](https://gemnasium.com/xentek/t_bird)\r\n- Code Quality: [![Code Climate](https://d3s6mut3hikguw.cloudfront.net/github/xentek/t_bird.png)](https://codeclimate.com/github/xentek/t_bird)\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 't_bird', require: false\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\n## Why?\r\n\r\nI became frustrated by the very coupled design of the leading ruby\r\nupload libraries and wanted something that was more modular (to\r\nallow for flexibility), wasn't glued to a `Model` (or any other class),\r\nand fulfilled my most common use case out of the box: \r\n\r\n - Upload an image, posted from a multi-part form,\r\n - process the file into 1 or more versions (resize, crop, etc),\r\n - and upload the file(s) to S3 for storage.\r\n\r\n## Usage\r\n\r\nFirst, configure `t_bird` with a few settings:\r\n\r\n````ruby\r\nrequire 't_bird'\r\nTBird::Configuration.configure |config|\r\n  config.aws_key 'amazon access key id'\r\n  config.aws_secret 'amazon secret access key'\r\n  config.aws_bucket 'name of s3 bucket that already exists'\r\n  config.thumbnail_size 100\r\nend\r\n````\r\nPlace this code so that it runs when your app boots.\r\n\r\n  - If you're using Sinatra or Rack, `config.ru` is probably a good spot.\r\n  - If you're using Rails, put the configuration in an initializer, e.g. `config/initializers/t_bird.rb`.\r\n\r\nThen, assuming you have a multipart form like this:\r\n\r\n````ruby\r\nform enctype=\"multipart/form-data\" method=\"POST\"\r\n  input type=\"file\" name=\"brand[image]\"\r\n  input type=\"submit\"\r\n````\r\n_Example is using [slim](http://slim-lang.com) for clarity and terseness, but that doesn't mean you have to._\r\n\r\nIn the action the form posts to, grab the uploaded file and upload it with `t_bird`:\r\n\r\n````ruby\r\n# prepended to your filename and enables you\r\n# to create a path to your file on S3\r\noptions = { identifier: \"images/brands\" }\r\n\r\n# instantiate your uploader, pass it your file\r\nuploader = TBird::Uploader.new(params[:brand][:image], options)\r\n\r\n# return value is the same as uploader.uploads\r\nuploader.upload!\r\n\r\n# returns a hash of the URL(s) to your uploads on S3\r\n# store this in the way that makes the most sense for your app\r\nbrand.images = uploader.uploads\r\n````\r\n\r\n- By default, there are two `versions` defined: `:thumbnail` and `:original`.\r\n- `:thumbnail` will create crop a square image from the upload.\r\n  - You can control the size of the square by setting `thumbnail_size` in your configuration (see above).\r\n- `:original` will be the raw, unadulterated file that the user submitted.\r\n\r\n## Options\r\n\r\nThere are three options you can pass into your `TBird::Uploader` instance:\r\n\r\n  - `:identifer`\r\n    - app specific identifer for his upload, e.g. your model's databae ID, the date or timestamp, whatever\r\n    - used as the folder this file's uploads are stored in on s3\r\n      - you can pass a path fragment here to create a folder heirarchy, e.g. 'uploads/images'\r\n      - don't want any folders?, just pass an empty string, e.g. `''`\r\n    - defaults to a `SHA1` digest of the `original_filename`\r\n    - value should be URL safe, no encoding is done for you by `t_bird`\r\n  - `:token`\r\n    - needs to be a unique value per upload, to help avoid name collisions and writing over any existing files\r\n    - used as part of the filename, version and extension are\r\n      automatically appended on to the end.\r\n    - defaults to a [UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier)\r\n      - think hard before straying from this strategy, UUIDs are generated quickly and\r\n        are nearly immune to collision (there is a higher probablity of you personally being\r\n        struck by a metorite than generating two UUIDs that have the same value.)\r\n    - value should be URL safe, no encoding is done for you by `t_bird`\r\n  - `:metadata`\r\n    - value must be a hash\r\n    - values in this hash will be stored, with your file, on S3\r\n      - this could be used for tagging your files, e.g. `tags: brands, images`, or anything else you might think of\r\n      - `t_bird` doesn't provide any read access to this metadata, once it's stored on S3. It's up to you to use S3's API to do anything with it.\r\n\r\n## Custom Uploaders\r\n\r\nIn order to define custom versions, and other advanced customization, create a subclass of `TBird::Uploader`:\r\n\r\n````ruby\r\nclass FileUploader < TBird::Uploader\r\n  version :original do\r\n    ->(file) { file.original }\r\n  end\r\nend\r\n````\r\n\r\n- In this simple example we have created a subclass and defined a single version, `:original`\r\n- No other versions were defined, so only `:original` will be created.\r\n  - In other words, if you create a subclass without any `versions` defined, your uploader\r\n    won't upload anything.\r\n\r\nHere's a more complex example that defines several custom `versions`:\r\n\r\n````ruby\r\nclass ComplexUploader < TBird::Uploader\r\n\r\n  # resizes image to a *width* of 200px, maintains aspect ratio\r\n  version :small do\r\n    ->(img) { img.resize '200' } \r\n  end\r\n\r\n  # resizes image to a *height* of 300px, maintains aspect ratio\r\n  version :large do\r\n    ->(img) { img.resize 'x300' }\r\n  end\r\n\r\n  # resizes image to a *height* of 300px, maintains aspect ratio\r\n  version :resized do\r\n    ->(img) { img.resize '500x300' }\r\n  end\r\n\r\n  # custom thumbnail size, allowing your to ignore\r\n  # the value of TBird::Configuration.thumbnail_size\r\n  # on an uploader by uploader basis\r\n  version :thumbnail do\r\n    ->(img) { img.thumbnail 200 }\r\n  end\r\n\r\n  # want MOAR power?\r\n  # use process, which gets you inside a\r\n  # MiniMagick::Image#combine_options block\r\n  version :complex do\r\n    lambda do |img|\r\n      img.process do |magick|\r\n        magick.sample \"50%\"\r\n        magick.rotate \"-90>\"\r\n        magick.quality '88'\r\n      end\r\n    end\r\n  end\r\nend\r\n````\r\nFor more information on `MiniMagick::Image#combine_options`, refer to the [mini_magick docs](https://github.com/minimagick/minimagick/blob/master/README.md).\r\n\r\n:skull: `TBird::Processor#process` can be a _very sharp stick_, so carefully test your processing code with a variety of files in a non-production environment, and as usual, be wary of using values from outside of your class as input for your processing routines.\r\n\r\n## More customization options\r\n\r\n  - Redefine the `namer` method in your subclass to switch out the object that's responsible for generating the name used on S3.\r\n    - Your object must respond to `new_name`, and take the `version`, which will be a symbol, as input.\r\n  - Redefine the `processor` method in your subclass to switch out the processing library.\r\n    - Blocks defined by the `version` macro will be passed an instance of your `processor`,\r\n      so be sure that your `processor` will respond to any methods the code inside your blocks call on it. \r\n  - Redefine the `upload!` method to remix the whole flow!\r\n    - really the sky's the limit here, but at some point you might be\r\n      better of just writing your own uploader class that doesn't sit on\r\n      top of `t_bird`\r\n    - Currently this is the only way to swith out S3 for another storage provider.\r\n      - Better support for changing the storage mechanism will likely come out in a future version.\r\n      - Talk to me __before working on a patch__ for this, so we can agree on implementation.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n6. ???\r\n7. Profit!\r\n\r\n#### Colophon\r\n\r\n  - This project was not named after the Thunderbird model of car. Ford Motor Company does not have any connection to, or responsibility for this project, and does not endorse it in any way (or even know it exists. Probably).\r\n  - Sample image, used in tests, was provided by [cherrylet](http://www.flickr.com/photos/cherrylet/10258332985/sizes/o/in/photostream/), under the Creative Commons 2.0. No endorsement of this library by the photographer is intended or implied.\r\n","google":"UA-102539-23","note":"Don't delete this file! It's used internally to help with page regeneration."}